###Day 1. Points. 
#Create a map of all casles and fortificattions, built on the territory of Ukraine.
library(ggplot2)
library(emoGG)
data <- read.csv("Castles.csv")
#plot points by coordinates
ggplot(data, aes(Lon, Lat, color = castle)) +
  geom_emoji(emoji="1f3f0")
#save in high resolution
ggsave("Castles.png", width = 25, height = 20, dpi=700)

###DAy 2. Lines.

install.packages("plotly")
library(plotly)
library(dplyr)
# airport locations
### reference HOW TO READ FROM GITHUB air <- read.csv('https://raw.githubusercontent.com/plotly/datasets/master/2011_february_us_airport_traffic.csv')
air <- read.csv("air.csv", encoding = "UTF-8", header = T, stringsAsFactors = F)
# flights between airports
flights <- read.csv("flights.csv", encoding = "UTF-8", header = T, stringsAsFactors = F)
flights$id <- seq_len(nrow(flights))

# map projection
geo <- list(
  scope = 'europe',
  projection = list(type = 'azimuthal equal area'),
  showland = TRUE,
  landcolor = toRGB("gray95"),
  countrycolor = toRGB("gray80")
)

fig <- plot_geo(locationmode = 'europe', color = I("blue"))
fig <- fig %>% add_markers(
  data = air, x = ~long, y = ~lat, text = ~airport,
  size = ~cnt, hoverinfo = "text", alpha = 0.5
)
fig <- fig %>% add_segments(
  data = group_by(flights, id),
  x = ~start_lon, xend = ~end_lon,
  y = ~start_lat, yend = ~end_lat,
  alpha = 0.3, size = I(1), hoverinfo = "none"
)
fig <- fig %>% layout(
  title = 'Juliana: flight paths<br>30DayMapChallenge Day 2 Lines',
  geo = geo, showlegend = FALSE, height=800
)

fig

###Day 3. Polygons.
library(usdm)
Belgium <- getData("GADM", country="BE", level=2) # Download Belgium boundary
plot(Belgium)
library(tidyverse) #can we actually code without it?
library(rgdal) #to import shapefiles
library(broom) #to convert shapefiles into the data frame structure we need
library(wesanderson) #for some nice color palettes
#dataprovided by Statbel https://statbel.fgov.be/en/news/11514-russians-and-5624-ukrainians-live-belgium
data <- read.csv("Ukraine.csv", encoding = "UTF-8", header = T, stringsAsFactors = F)
data$id <- as.character(data$id)
class(data$id)
regional_df <- tidy(Belgium)
#Joining
regional_df2 <- left_join(regional_df, data, by="id")
summary(regional_df)
library(ggplot2)

map1<-ggplot(regional_df2, aes( x = long, y = lat, group=group)) +
  geom_polygon(aes(fill = value), color = "black")
map1

map2 <- map1 + scale_fill_gradient(low = "aquamarine", high =  "blue", na.value = "grey50")+
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.y=element_blank(),
        axis.title.x=element_blank(),
        rect = element_blank()) +
  labs(title="Ukrainians among the population of Belgium, calculated as a share of 1",
       subtitle="Data obtained from statbel.fgov.be",
       caption = "situation on 1 January 2021")
map2

### Pixel map
Ukraine <- getData("GADM", country="UA", level=1)
plot(Ukraine)
ggplot(Ukraine, aes(long,lat, group=group)) +
  geom_polygon() +
  coord_map() +
  theme_void()
#here’s is the tip for creating a pixel effect : round the long and lat, 
#in order to make the border more squared (now, we’ll also fill according to groups)

p <- ggplot(Ukraine, aes(round(long, 1),round(lat,1), group=group,fill = as.factor(group))) +
  geom_polygon() +
  guides(fill=FALSE) +
  coord_map() +
  theme_void()
library(dutchmasters)  
devtools::install_github("EdwinTh/dutchmasters")
p + scale_fill_dutchmasters(palette = "view_of_Delft")

